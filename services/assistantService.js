import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';

// Import all your existing service functions
import { getUpcomingEvents, formatEventForResponse } from './calendarService.js';
import { geocodeAddress, getTravelTime } from './mapsService.js';
import { createDocument, createPresentation } from './docsService.js';
import { getMessages, searchMessages } from './gmailService.js';
import { getContacts, searchContacts } from './peopleService.js';
import { getTasks, getUpcomingTasks, createTask } from './tasksService.js';
import { getMeetLinksFromCalendar, getNextMeetLink, createMeetEvent } from './meetService.js';
import { listFiles, searchFiles, getRecentFiles, getFilesByType, MIME_TYPES } from './driveService.js';
import { createNote, getNotes, searchNotes } from './keepService.js';
import { createSpreadsheet } from './sheetsService.js';
// New service imports
import { googleSearch } from './searchService.js';
import { createForm, getForm, listForms, updateForm, deleteForm, addQuestionToForm, addQuestionsToForm, updateQuestion, deleteQuestion, getFormResponses } from './formsService.js';
import { searchVideos, getVideoDetails, getChannelInfo, getMyPlaylists } from './youtubeService.js';
import { getWeather, getWeatherForecast } from './weatherService.js';
import { searchPlaces, getPlaceDetails, getNearbyPlaces } from './placesService.js';
import { getTimezone, getTimezonesForLocations } from './timezoneService.js';
import { getAirQuality, getAirQualityForecast } from './airQualityService.js';

dotenv.config();

export class GoogleAssistant {
  constructor(tokens) {
    this.tokens = tokens;

    // 1. Initialize the Generative AI model
    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    
    // 2. Define the tools (your handler functions)
    const tools = this.getTools();
    
    // 3. Configure the model to use these tools
    // Note: Supported models: gemini-2-flash, gemini-2.5-flash, gemini-2-flash-lite, gemini-2.5-flash-lite, gemini-2.5-pro
    this.model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      tools: tools,
    });

    // 4. Create a map to call functions by name
    this.availableTools = {
      handleLocationQuery: (args, loc) => this.handleLocationQuery(args.query, loc),
      handleMeetingTravelWithLocation: (args, loc) => this.handleMeetingTravelWithLocation(args.query, loc),
      handleScheduleQuery: (args, loc) => this.handleScheduleQuery(args.query, loc),
      handleTravelQuery: (args, loc) => this.handleTravelQuery(args.query, loc),
      handleMeetingTravelQuery: (args, loc) => this.handleMeetingTravelQuery(args.query, loc),
      handleDocumentQuery: (args, loc) => this.handleDocumentQuery(args.query, loc),
      handleTasksQuery: (args, loc) => this.handleTasksQuery(args.query, loc),
      handleContactsQuery: (args, loc) => this.handleContactsQuery(args.query, loc),
      handleMeetQuery: (args, loc) => this.handleMeetQuery(args.query, loc),
      handleDriveQuery: (args, loc) => this.handleDriveQuery(args.query, loc),
      handleNotesQuery: (args, loc) => this.handleNotesQuery(args.query, loc),
      handleGmailQuery: (args, loc) => this.handleGmailQuery(args.query, loc),
      handleSearchQuery: (args, loc) => this.handleSearchQuery(args.query, loc),
      handleFormsQuery: (args, loc) => this.handleFormsQuery(args.query, loc),
      handleYouTubeQuery: (args, loc) => this.handleYouTubeQuery(args.query, loc),
      handleWeatherQuery: (args, loc) => this.handleWeatherQuery(args.query, loc),
      handlePlacesQuery: (args, loc) => this.handlePlacesQuery(args.query, loc),
      handleTimezoneQuery: (args, loc) => this.handleTimezoneQuery(args.query, loc),
      handleAirQualityQuery: (args, loc) => this.handleAirQualityQuery(args.query, loc),
    };
  }

  /**
   * Process user query using Gemini with function calling.
   * All responses are generated by Gemini, not hardcoded.
   * @param {string} query - User's query
   * @param {string|null} currentLocation - Current location coordinates
   * @param {Array} conversationHistory - Previous conversation messages
   * @param {Object} context - Session context from database
   * @param {Object} userPreferences - User preferences
   */
  async processQuery(query, currentLocation = null, conversationHistory = [], context = {}, userPreferences = {}) {
    try {
      if (!process.env.GEMINI_API_KEY) {
        throw new Error('GEMINI_API_KEY is not set in environment variables');
      }

      // Build context information for system instructions
      let contextInfo = '';
      
      if (context && Object.keys(context).length > 0) {
        contextInfo += '\n\nPREVIOUS CONTEXT:\n';
        if (context.lastQuery) contextInfo += `- Last query: ${context.lastQuery}\n`;
        if (context.lastEvents && context.lastEvents.length > 0) {
          contextInfo += `- Recent events: ${context.lastEvents.length} events found\n`;
        }
        if (context.lastMeeting) {
          contextInfo += `- Last meeting discussed: ${context.lastMeeting.summary || 'Meeting'}\n`;
        }
        if (context.lastTravelTimes) {
          contextInfo += `- Recent travel time calculated\n`;
        }
        if (context.lastVideos && context.lastVideos.length > 0) {
          contextInfo += `- Recently searched ${context.lastVideos.length} YouTube videos\n`;
        }
        if (context.lastWeather) {
          contextInfo += `- Recently checked weather for: ${context.lastWeather.location || 'location'}\n`;
        }
        if (context.lastPlaces && context.lastPlaces.length > 0) {
          contextInfo += `- Recently found ${context.lastPlaces.length} places\n`;
        }
        if (context.lastForms && context.lastForms.length > 0) {
          contextInfo += `- Recently accessed ${context.lastForms.length} forms\n`;
        }
        if (context.lastResults && context.lastResults.length > 0) {
          contextInfo += `- Recent search results found\n`;
        }
      }
      
      if (conversationHistory && conversationHistory.length > 0) {
        contextInfo += `\nCONVERSATION HISTORY: You have ${conversationHistory.length} previous messages in this conversation. Use this context to understand references to previous topics, follow-up questions, and maintain continuity.\n`;
      }
      
      if (userPreferences && Object.keys(userPreferences).length > 0) {
        contextInfo += `\nUSER PREFERENCES: ${JSON.stringify(userPreferences)}\n`;
      }
      
      // System instructions for Gemini
      // For Gemini 2.x, systemInstruction needs to be a Content object with parts
      const systemInstructionText = `You are a powerful Google Workspace assistant with FULL ACCESS to all Google services. You have complete CRUD (Create, Read, Update, Delete) capabilities for all tools.

IMPORTANT - YOUR FULL CAPABILITIES:
- DOCUMENTS/SLIDES/SHEETS: You can CREATE, VIEW, EDIT, MODIFY, DELETE, and manage any Google Docs, Slides, or Sheets. You can create new ones, edit existing ones, append content, modify structure, and delete files.
- GMAIL: You can VIEW emails, SEARCH emails, and SEND emails. You have full access to read and send messages.
- CALENDAR: You can VIEW events, CREATE events, EDIT events, DELETE events, and manage the entire calendar. You can create any type of event, modify existing ones, and delete them.
- DRIVE: You can LIST files, SEARCH files, VIEW files, and access any file in Google Drive.
- TASKS: You can VIEW tasks, CREATE tasks, COMPLETE tasks, and manage task lists.
- CONTACTS: You can VIEW contacts, SEARCH contacts, and access contact information.
- GOOGLE MEET: You can CREATE meeting links, VIEW upcoming meetings, and manage Meet events.
- NOTES (Google Keep): You can CREATE notes, VIEW notes, SEARCH notes, and manage all notes.
- MAPS: You can get locations, calculate travel times, get directions, and geocode addresses.
- GOOGLE SEARCH: You can SEARCH the web using Google Search to find information, articles, websites, and any web content.
- GOOGLE FORMS: You can CREATE, VIEW, EDIT, DELETE, and manage Google Forms with FULL QUESTION EDITING. You can create forms WITH QUESTIONS (text, multiple choice, checkbox, dropdown, paragraph, scale, date, time, file upload), add questions to existing forms, edit/update questions (change title, options, required status), delete questions, view forms, edit forms, delete forms, and view form responses. When creating forms, always include the questions with their types and options.
- YOUTUBE: You can SEARCH YouTube videos, get video details, channel information, and access playlists. You can search for videos, get video information, channel details, and manage playlists.
- WEATHER: You can get CURRENT WEATHER and FORECASTS for any location. You can get weather conditions, temperature, forecasts, and detailed weather information.
- PLACES: You can SEARCH places, get place details, and find nearby places using Google Places API. You can search for restaurants, businesses, attractions, get place information, reviews, and find nearby locations.
- TIMEZONE: You can get TIMEZONE information for any location. You can get timezone details, local time, UTC offset, and timezone conversions.
- AIR QUALITY: You can get AIR QUALITY information and forecasts for any location. You can get current air quality index (AQI), pollutants, air quality forecasts, and pollution levels.

INSTRUCTIONS:
1. When a user asks for ANY action (create, edit, delete, view, modify), use the appropriate tools to perform it
2. You have FULL PERMISSIONS - don't hesitate to create, edit, or delete anything the user requests
3. For complex requests, use multiple tools as needed
4. After receiving tool results, generate a natural, helpful response based on the data
5. Be conversational, clear, and concise
6. Present structured data (events, emails, files, contacts, etc.) in a user-friendly format
7. Include relevant links, times, and details when available
8. Always confirm actions taken (e.g., "I've created...", "I've deleted...", "I've updated...")
9. If the user wants to modify or delete something, do it - you have full permissions
10. Use conversation history and context to understand references to previous topics (e.g., "that meeting", "the document I created", "my schedule")

The user's current location is: ${currentLocation || 'not available'}. Use this for travel time calculations when relevant.${contextInfo}`;

      // Prepare conversation history for Gemini
      // Gemini expects history as an array of message objects with role and parts
      let chatHistory = [];
      if (conversationHistory && conversationHistory.length > 0) {
        // Take last 10 messages for context (Gemini has token limits)
        const recentHistory = conversationHistory.slice(-10);
        chatHistory = recentHistory.map(msg => {
          const role = msg.type === 'user' ? 'user' : 'model';
          const content = msg.content || msg.metadata?.content || '';
          return {
            role: role,
            parts: [{ text: content }]
          };
        });
      }

      // Start chat with system instruction and history
      const chatConfig = {
        systemInstruction: {
          parts: [{ text: systemInstructionText }]
        }
      };
      
      // Add history if available (Gemini 2.x supports history in startChat)
      if (chatHistory.length > 0) {
        chatConfig.history = chatHistory;
      }
      
      const chat = this.model.startChat(chatConfig);

      // Build query with context if needed
      let enhancedQuery = query;
      
      // If there's context and the query seems like a follow-up, add context hint
      if (context && conversationHistory.length > 0) {
        const recentContext = [];
        if (context.lastEvents && context.lastEvents.length > 0) {
          recentContext.push(`Previously discussed ${context.lastEvents.length} events`);
        }
        if (context.lastMeeting) {
          recentContext.push(`Previously discussed meeting: ${context.lastMeeting.summary || 'meeting'}`);
        }
        if (context.lastVideos && context.lastVideos.length > 0) {
          recentContext.push(`Previously searched ${context.lastVideos.length} YouTube videos`);
        }
        if (context.lastWeather) {
          recentContext.push(`Previously checked weather for ${context.lastWeather.location || 'location'}`);
        }
        if (context.lastPlaces && context.lastPlaces.length > 0) {
          recentContext.push(`Previously found ${context.lastPlaces.length} places`);
        }
        if (context.lastForms && context.lastForms.length > 0) {
          recentContext.push(`Previously accessed ${context.lastForms.length} forms`);
        }
        if (context.lastQuery) {
          recentContext.push(`Previous query: ${context.lastQuery.substring(0, 50)}...`);
        }
        
        // Add context hint for follow-up questions
        if (recentContext.length > 0) {
          enhancedQuery = `${query}\n\n[Previous context: ${recentContext.join('; ')}]`;
        }
      }

      // Send initial query
      const result = await chat.sendMessage(enhancedQuery);
      const response = result.response;
      
      // Check for function calls
      const functionCalls = response.functionCalls();
      
      if (functionCalls && functionCalls.length > 0) {
        // Execute all function calls and collect results
        const functionResponses = [];
        
        for (const call of functionCalls) {
        const toolName = call.name;
        const tool = this.availableTools[toolName];

        if (!tool) {
            functionResponses.push({
              name: toolName,
              response: {
                error: `Tool ${toolName} not found`,
                availableTools: Object.keys(this.availableTools)
              }
            });
            continue;
          }

          try {
            // Call the tool and get raw data
        const toolResult = await tool(call.args, currentLocation);
        
            // Store the raw result
            functionResponses.push({
            name: toolName,
            response: toolResult
            });
          } catch (error) {
            functionResponses.push({
              name: toolName,
              response: {
                error: error.message,
                type: 'error'
              }
            });
          }
        }
        
        // Send all function responses back to Gemini
        // Note: FunctionResponse cannot be mixed with text in the same message
        const functionResponseParts = functionResponses.map(fr => ({
          functionResponse: {
            name: fr.name,
            response: fr.response
          }
        }));

        // First, send function responses
        await chat.sendMessage(functionResponseParts);

        // Then, send the prompt in a separate message
        const responsePrompt = `Based on the tool results above, please provide a helpful, natural response to the user's original query: "${query}"

Guidelines:
- Use the tool results to answer the user's question completely
- Format information clearly (e.g., list events with times, show travel times with details)
- Include relevant links, locations, and metadata when available
- If the results contain structured data (events, emails, files, contacts, etc.), present it in an organized, readable format
- Be conversational and helpful
- If there were any errors, mention them clearly but continue with available information
- Always provide actionable information or next steps when relevant`;

        const finalResult = await chat.sendMessage(responsePrompt);
        
        const finalResponse = finalResult.response;
        const finalText = finalResponse.text();
        
        // Extract any additional data from tool results for the frontend
        const additionalData = {};
        functionResponses.forEach(fr => {
          if (fr.response && typeof fr.response === 'object') {
            Object.keys(fr.response).forEach(key => {
              if (['events', 'travelTimes', 'meeting', 'contacts', 'tasks', 'files', 'notes', 'messages', 'link', 
                   'videos', 'weather', 'forecasts', 'places', 'timezone', 'forms', 'results', 'playlists', 
                   'channel', 'video', 'place', 'searchResults'].includes(key)) {
                additionalData[key] = fr.response[key];
              }
            });
          }
        });
        
        return {
          type: 'text',
          content: finalText || 'No response generated',
          ...additionalData
        };
      } else {
        // No tool call, just return Gemini's response
        const text = response.text();
          return { 
            type: 'text', 
          content: text || "I'm here to help! What would you like to know?" 
          };
      }
    } catch (error) {
      console.error('Error processing query with Gemini:', error);
      console.error('Error details:', error.stack);
      return { 
        type: 'error', 
        content: `Error processing query: ${error.message}. Please check that GEMINI_API_KEY is set and the API is working.` 
      };
    }
  }

  /**
   * NEW: Defines all handler methods as "tools" for the LLM.
   */
  getTools() {
    const stringQueryParam = {
      type: "STRING",
      description: "The user's full, original query, e.g., 'what's my schedule today' or 'how long to get to the office'",
    };
    
    // For Gemini 2.x, tools must be wrapped in functionDeclarations
    return [
      {
        functionDeclarations: [
      {
        name: 'handleLocationQuery',
        description: "Gets the user's current latitude, longitude, and address. Use for queries like 'where am I' or 'what is my location'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleScheduleQuery',
            description: "FULL CALENDAR MANAGEMENT: View, create, edit, delete, and manage calendar events. Gets upcoming events, schedules, meetings, and appointments. Can also create new events, modify existing ones, delete events, and manage the entire calendar. Use for 'what's on my schedule', 'do I have any meetings', 'create a meeting', 'delete my 3pm meeting', 'edit the meeting tomorrow', 'schedule a call with John'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleTravelQuery',
        description: "Calculates travel time and directions between two locations. Use for 'how long to get to...', 'directions from X to Y', 'travel time from my location'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleMeetingTravelWithLocation',
        description: "Calculates travel time from the user's current location to their next meeting. Use for 'how long to my next meeting'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleMeetingTravelQuery',
        description: "Finds the user's next meeting and its location, but does not calculate travel time. Use if `handleMeetingTravelWithLocation` is not suitable.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleDocumentQuery',
            description: "FULL DOCUMENT/SLIDE/SHEET MANAGEMENT: Create, view, edit, modify, delete, and manage Google Docs, Slides, and Sheets. Can create new documents/presentations/spreadsheets, edit existing ones, append content, modify structure, delete files, and perform any document operation. Use for 'create a doc', 'make a presentation', 'new spreadsheet', 'edit my document', 'delete the presentation', 'modify the spreadsheet', 'add content to my doc'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleTasksQuery',
            description: "FULL TASK MANAGEMENT: View, create, complete, and manage tasks. Can view all tasks, create new tasks, complete tasks, and manage task lists. Use for 'what are my tasks', 'create a new task', 'add to my to-do', 'complete the task about...', 'mark task as done', 'show my upcoming tasks'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleContactsQuery',
            description: "FULL CONTACTS MANAGEMENT: View, search, and access contacts. Can view all contacts, search for specific contacts, get contact details including emails and phone numbers. Use for 'find John's email', 'search for contact Lisa', 'show me my contacts', 'get contact info for...'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleMeetQuery',
            description: "FULL MEET MANAGEMENT: Create, view, and manage Google Meet meetings. Can create new meeting links, view upcoming meetings, get meeting links, and manage Meet events. Use for 'what's my next meeting link', 'create a new meet link', 'schedule a Google Meet', 'get my meeting link'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleDriveQuery',
            description: "FULL DRIVE MANAGEMENT: View, search, list, access, and manage files in Google Drive. Can find files, search for specific files, list recent files, view files by type, and access any file. Use for 'find my file', 'search for report.pdf in Drive', 'list my recent files', 'show me my spreadsheets', 'get my documents'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleNotesQuery',
            description: "FULL NOTES MANAGEMENT: Create, view, search, and manage notes in Google Keep. Can create new notes, view all notes, search for specific notes, and manage all notes. Use for 'create a note', 'find my notes about...', 'show me my notes', 'search for notes with...'.",
        parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
      },
      {
        name: 'handleGmailQuery',
            description: "FULL GMAIL MANAGEMENT: View emails, search emails, send emails, and manage Gmail. Can read messages, search for specific emails, send new emails, and perform any Gmail operation. Use for 'check my email', 'search for emails from John', 'send an email to...', 'read my latest emails', 'find emails about...'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handleSearchQuery',
            description: "GOOGLE SEARCH: Search the web using Google Search. Can search for information, articles, websites, and any web content. Use for 'search for...', 'find information about...', 'google...', 'look up...'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handleFormsQuery',
            description: "FULL FORMS MANAGEMENT: Create, view, edit, delete, and manage Google Forms with full question editing capabilities. Can create new forms WITH QUESTIONS (text, multiple choice, checkbox, dropdown, paragraph, scale, date, time, file upload), add questions to existing forms, edit/update questions (title, options, required status), delete questions, view forms, edit forms, delete forms, and view form responses. When creating forms, you can specify questions with types and options. Use for 'create a form with questions', 'make a survey with multiple choice questions', 'add a question to form', 'edit question in form', 'update question options', 'delete question from form', 'view form responses'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handleYouTubeQuery',
            description: "YOUTUBE DATA ACCESS: Search YouTube videos, get video details, channel information, and playlists. Can search for videos, get video information, channel details, and access user playlists. Use for 'search YouTube for...', 'find videos about...', 'get video details', 'show me my playlists', 'channel info for...'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handleWeatherQuery',
            description: "WEATHER DATA: Get current weather and forecasts for any location. Can get current weather conditions, temperature, forecasts, and weather details. Use for 'what's the weather', 'weather forecast', 'temperature in...', 'weather in New York'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handlePlacesQuery',
            description: "PLACES DATA: Search places, get place details, find nearby places using Google Places API. Can search for restaurants, businesses, attractions, get place information, reviews, and find nearby locations. Use for 'find restaurants near me', 'search for coffee shops', 'place details for...', 'nearby places'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handleTimezoneQuery',
            description: "TIMEZONE DATA: Get timezone information for any location. Can get timezone details, local time, UTC offset, and timezone conversions. Use for 'what time is it in...', 'timezone for New York', 'local time in London', 'timezone conversion'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          },
          {
            name: 'handleAirQualityQuery',
            description: "AIR QUALITY DATA: Get air quality information and forecasts for any location. Can get current air quality index (AQI), pollutants, air quality forecasts, and pollution levels. Use for 'air quality in...', 'AQI for New York', 'pollution levels', 'air quality forecast', 'what's the air quality'.",
            parameters: { type: "OBJECT", properties: { query: stringQueryParam }, required: ['query'] }
          }
        ]
      }
    ];
  }

  // =================================================================
  // ALL HANDLER FUNCTIONS REMAIN BELOW
  // We just update their signatures to accept (query, currentLocation)
  // =================================================================

  async handleLocationQuery(query, currentLocation = null) {
    if (!currentLocation) {
      return {
        locationAvailable: false,
        message: "Current location is not available. Please enable location permissions or provide location explicitly."
      };
    }
    
    try {
      const [lat, lng] = currentLocation.split(',');
      const latNum = parseFloat(lat);
      const lngNum = parseFloat(lng);
      
      let address = null;
      
      // Reverse geocode to get address
      try {
        const axios = (await import('axios')).default;
        const GOOGLE_MAPS_API_KEY = process.env.GOOGLE_MAPS_API_KEY || '';
        let apiKey = GOOGLE_MAPS_API_KEY;
        if (apiKey.startsWith('"') && apiKey.endsWith('"')) {
          apiKey = apiKey.slice(1, -1);
        }
        
        const response = await axios.get('https://maps.googleapis.com/maps/api/geocode/json', {
          params: {
            latlng: `${latNum},${lngNum}`,
            key: apiKey
          }
        });
        
        if (response.data.results && response.data.results.length > 0) {
          address = response.data.results[0].formatted_address;
        }
      } catch (error) {
        // If reverse geocoding fails, continue without address
      }
      
      return {
        locationAvailable: true,
        latitude: latNum,
        longitude: lngNum,
        address: address,
        coordinates: `${latNum},${lngNum}`
      };
    } catch (error) {
      return {
        error: true,
        message: `Error getting location: ${error.message}`
      };
    }
  }

  async handleMeetingTravelWithLocation(query, currentLocation = null) {
    try {
      const events = await getUpcomingEvents(this.tokens, 5);
      const now = new Date();
      const nextMeeting = events
        .map(formatEventForResponse)
        .find(event => {
          const startTime = new Date(event.start);
          return startTime > now && event.location && event.location !== 'No location specified';
        });
      
      if (!nextMeeting) {
        return {
          meetingFound: false,
          message: "No upcoming meeting with a location found."
        };
      }
      
      // Geocode meeting location
      const meetingCoords = await geocodeAddress(nextMeeting.location);
      if (!meetingCoords) {
        return {
          meetingFound: true,
          meeting: nextMeeting,
          locationGeocoded: false,
          location: nextMeeting.location,
          message: `Found meeting "${nextMeeting.summary}" but could not geocode location: ${nextMeeting.location}`
        };
      }
      
      // Check if current location is available
      if (!currentLocation) {
        return {
          meetingFound: true,
          meeting: nextMeeting,
          locationGeocoded: true,
          meetingLocation: meetingCoords,
          currentLocationAvailable: false,
          message: `Next meeting is at ${nextMeeting.location}. Current location needed for travel time calculation.`
        };
      }
      
      // Calculate travel time
      const travelTimes = await getTravelTime(
        currentLocation,
        `${meetingCoords.lat},${meetingCoords.lng}`
      );
      
      const timeUntil = this.getTimeUntilInHours(new Date(nextMeeting.start));
      let suggestedDeparture = null;
      
      if (travelTimes.driving && timeUntil > 0) {
        const driveTimeHours = travelTimes.driving.durationValue / 3600;
        suggestedDeparture = new Date(new Date(nextMeeting.start).getTime() - (driveTimeHours * 60 * 60 * 1000) - (15 * 60 * 1000));
      }
      
      return {
        meetingFound: true,
        meeting: nextMeeting,
        locationGeocoded: true,
        meetingLocation: meetingCoords,
        currentLocationAvailable: true,
        travelTimes: travelTimes,
        timeUntilMeeting: timeUntil,
        suggestedDeparture: suggestedDeparture ? suggestedDeparture.toISOString() : null
      };
    } catch (error) {
      return {
        error: true,
        message: `Error calculating travel time to meeting: ${error.message}`
      };
    }
  }

  async handleScheduleQuery(query, currentLocation = null) {
    try {
      const events = await getUpcomingEvents(this.tokens, 10);
      const formattedEvents = events.map(formatEventForResponse);
      
      if (formattedEvents.length === 0) {
        return {
          eventsFound: false,
          events: [],
          message: "No upcoming events found in the next 7 days."
        };
      }
      
      // Find next meeting
      const now = new Date();
      const nextMeeting = formattedEvents.find(event => {
        const startTime = new Date(event.start);
        return startTime > now;
      });
      
      return {
        eventsFound: true,
        events: formattedEvents,
        eventCount: formattedEvents.length,
        nextMeeting: nextMeeting || null,
        currentTime: now.toISOString()
      };
    } catch (error) {
      return {
        error: true,
        message: `Error fetching schedule: ${error.message}`
      };
    }
  }

  async handleTravelQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    // NOTE: The LLM should route 'next meeting' queries to the specific
    // handlers, so this check is less critical but good as a fallback.
    if (lowerQuery.includes('next meeting') || lowerQuery.includes('my meeting')) {
      if (currentLocation) {
        return await this.handleMeetingTravelWithLocation(query, currentLocation);
      } else {
        return await this.handleMeetingTravelQuery(query, currentLocation);
      }
    }
    
    // Extract origin and destination from query
    let origin = null;
    let destination = null;
    
    const hasMyLocation = /\b(my\s+)?(current\s+)?location\b/i.test(query);
    
    // Pattern 1: "to Y from X"
    const toFromMatch = query.match(/to\s+(.+?)\s+from\s+(.+?)(?:\s|$|\.|,)/i);
    if (toFromMatch) {
      destination = toFromMatch[1].trim();
      const originText = toFromMatch[2].trim();
      if (originText.toLowerCase().match(/\b(my\s+)?(current\s+)?location\b/i)) {
        origin = null; // Will use currentLocation
      } else {
        origin = originText;
      }
    } else {
      // Pattern 2: "from X to Y"
      const fromToMatch = query.match(/from\s+(.+?)\s+to\s+(.+?)(?:\s|$|\.|,)/i);
      if (fromToMatch) {
        const originText = fromToMatch[1].trim();
        destination = fromToMatch[2].trim();
        if (originText.toLowerCase().match(/\b(my\s+)?(current\s+)?location\b/i)) {
          origin = null; // Will use currentLocation
        } else {
          origin = originText;
        }
      } else {
        // Pattern 3: "to Y"
        const destMatch = query.match(/to\s+([^,\.]+?)(?:\s+from|\s*$|\.|,)/i);
        if (destMatch) {
          destination = destMatch[1].trim();
          if (hasMyLocation) {
            origin = null; // Will use currentLocation
          }
        }
        
        // Pattern 4: "from X"
        if (!origin) {
          const originMatch = query.match(/from\s+([^,\.]+?)(?:\s+to|\s*$|\.|,)/i);
          if (originMatch) {
            const originText = originMatch[1].trim();
            if (originText.toLowerCase().match(/\b(my\s+)?(current\s+)?location\b/i)) {
              origin = null; // Will use currentLocation
            } else {
              origin = originText;
            }
          }
        }
      }
    }
    
    // Clean up
    if (origin) {
      origin = origin.replace(/\s+(to|from|go|going|get|getting|location|my|current)$/i, '').trim();
      if (origin.toLowerCase().match(/\b(my\s+)?(current\s+)?location\b/i) || origin.length < 3) {
        origin = null;
      }
    }
    if (destination) {
      destination = destination.replace(/^(go\s+to\s+|to\s+)/i, '').trim();
      destination = destination.replace(/\s+(to|from|go|going|get|getting|location|my|current)$/i, '').trim();
      destination = destination.replace(/\s+from\s+(my\s+)?(current\s+)?location$/i, '').trim();
    }
    
    if (!destination) {
      return {
        error: true,
        message: "Please specify a destination. Example: 'How long from Times Square to Central Park?'"
      };
    }
    
    try {
      // Geocode addresses
      const destCoords = await geocodeAddress(destination);
      if (!destCoords) {
        return {
          error: true,
          message: `Could not find location: ${destination}`
        };
      }
      
      let originCoords = null;
      if (origin) {
        originCoords = await geocodeAddress(origin);
        if (!originCoords) {
          return {
            error: true,
            message: `Could not find location: ${origin}`
          };
        }
      } else if (currentLocation) {
        try {
          const [lat, lng] = currentLocation.split(',');
          originCoords = {
            lat: parseFloat(lat),
            lng: parseFloat(lng),
            address: 'Your current location'
          };
        } catch (err) {
          return {
            error: true,
            message: "Could not parse your current location. Please provide your location explicitly."
          };
        }
      } else {
        return {
          error: true,
          message: "Please provide your current location or enable location sharing. Example: 'How long from Times Square to Central Park?'"
        };
      }
      
      const travelTimes = await getTravelTime(
        `${originCoords.lat},${originCoords.lng}`,
        `${destCoords.lat},${destCoords.lng}`
      );
      
      return {
        origin: originCoords,
        destination: destCoords,
        travelTimes: travelTimes
      };
    } catch (error) {
      return {
        error: true,
        message: `Error calculating travel time: ${error.message}`
      };
    }
  }

  async handleMeetingTravelQuery(query, currentLocation = null) {
    try {
      const events = await getUpcomingEvents(this.tokens, 5);
      const now = new Date();
      const nextMeeting = events
        .map(formatEventForResponse)
        .find(event => {
          const startTime = new Date(event.start);
          return startTime > now && event.location && event.location !== 'No location specified';
        });
      
      if (!nextMeeting) {
        return {
          meetingFound: false,
          message: "No upcoming meeting with a location found. Make sure your meetings have location information."
        };
      }
      
      return {
        meetingFound: true,
        meeting: nextMeeting,
        currentLocationAvailable: currentLocation ? true : false
      };
    } catch (error) {
      return {
        error: true,
        message: `Error finding next meeting: ${error.message}`
      };
    }
  }

  async handleDocumentQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    const isPresentation = lowerQuery.includes('presentation') || lowerQuery.includes('slide');
    const isSpreadsheet = lowerQuery.includes('spreadsheet') || lowerQuery.includes('sheet') && !lowerQuery.includes('document');
    
    // Improved title and content extraction
    let title = null;
    let content = '';
    
    // Pattern 1: "create document called X about Y" or "create document X about Y"
    const pattern1 = query.match(/(?:create|generate|make) (?:a |an )?(?:report|presentation|document|slide|spreadsheet|sheet) (?:called |named |titled )?([^:]+?)(?: about| with| containing| that says|:)/i);
    if (pattern1) {
      title = pattern1[1].trim();
    }
    
    // Pattern 2: "create document: Title - Content"
    const pattern2 = query.match(/(?:create|generate|make) (?:a |an )?(?:report|presentation|document|slide|spreadsheet|sheet):\s*(.+?)\s*-\s*(.+)/i);
    if (pattern2) {
      title = pattern2[1].trim();
      content = pattern2[2].trim();
    }
    
    // Pattern 3: Extract content after "that says", "with content", "containing", etc.
    const contentPatterns = [
      /(?:that says|saying|with content|containing|including|with text|with information)[:\s]+(.+?)(?:$|called|named)/is,
      /:\s*(.+?)(?:$|called|named)/is,
      /about\s+(.+?)(?:$|with|containing|that says)/is
    ];
    
    for (const pattern of contentPatterns) {
      const match = query.match(pattern);
      if (match && match[1]) {
        const extracted = match[1].trim();
        // Only use if it's substantial content (more than just a title)
        if (extracted.length > 20 || extracted.includes('\n') || extracted.split(' ').length > 5) {
          content = extracted;
          break;
        }
      }
    }
    
    // If no title extracted yet, try simpler patterns
    if (!title) {
      const simpleTitleMatch = query.match(/(?:create|generate|make) (?:a |an )?(?:report|presentation|document|slide|spreadsheet|sheet) (?:called |named |titled )?([^:]+?)(?:$|about|with|containing)/i);
      if (simpleTitleMatch) {
        title = simpleTitleMatch[1].trim();
        // Remove common stop words from end
        title = title.replace(/\s+(about|with|containing|that|says)$/i, '').trim();
      }
    }
    
    // If still no title, use a default based on document type
    if (!title || title.length < 2) {
      if (isPresentation) {
        title = 'New Presentation';
      } else if (isSpreadsheet) {
        title = 'New Spreadsheet';
      } else {
        title = 'New Document';
      }
    }
    
    // Generate content if none extracted
    if (!content || content.length < 10) {
      // Try to extract topic from "about X"
      const aboutMatch = query.match(/about\s+(.+?)(?:$|with|containing|that says)/i);
      if (aboutMatch) {
        const topic = aboutMatch[1].trim();
        if (isPresentation) {
          content = `Presentation: ${title}\n\nTopic: ${topic}\n\nSlide 1: Introduction\nWelcome to this presentation about ${topic}.\n\nSlide 2: Overview\n${topic} is an important subject that we will explore in detail.\n\nSlide 3: Key Points\n- Important aspect 1 of ${topic}\n- Important aspect 2 of ${topic}\n- Important aspect 3 of ${topic}\n\nSlide 4: Conclusion\nThis presentation has covered the main aspects of ${topic}.\n\nGenerated on ${new Date().toLocaleDateString()}.`;
        } else if (isSpreadsheet) {
          content = ''; // Spreadsheets use data arrays, not text content
        } else {
          content = `${title}\n\nIntroduction\nThis document provides comprehensive information about ${topic}.\n\nOverview\n${topic} is a significant subject that requires detailed examination and analysis. This document aims to provide a thorough understanding of the key aspects, implications, and considerations related to ${topic}.\n\nKey Points\n\n1. Understanding ${topic}\n   ${topic} encompasses various important elements that are crucial to consider.\n\n2. Analysis and Insights\n   A detailed analysis of ${topic} reveals several important factors and considerations.\n\n3. Recommendations\n   Based on the analysis, there are several recommendations and next steps related to ${topic}.\n\nConclusion\nThis document has provided an overview and analysis of ${topic}. Further research and consideration may be needed to fully understand all aspects of this topic.\n\nGenerated by Google AIO Assistant on ${new Date().toLocaleDateString()}.`;
        }
      } else {
        // Default meaningful content
        if (isPresentation) {
          content = `Presentation: ${title}\n\nIntroduction\nWelcome to this presentation.\n\nOverview\nThis presentation covers important topics and information.\n\nKey Points\n- Point 1\n- Point 2\n- Point 3\n\nConclusion\nThank you for your attention.\n\nGenerated on ${new Date().toLocaleDateString()}.`;
        } else if (isSpreadsheet) {
          content = ''; // Will use data array
        } else {
          content = `${title}\n\nIntroduction\nThis document contains important information and details.\n\nContent\nThis document has been created to provide you with relevant information and insights.\n\nDetails\nPlease review the content and feel free to edit or expand upon it as needed.\n\nConclusion\nThis document serves as a starting point for your work.\n\nGenerated by Google AIO Assistant on ${new Date().toLocaleDateString()}.`;
        }
      }
    }
    
    try {
      if (isSpreadsheet) {
        // For spreadsheets, create meaningful data
        const data = [
          ['Item', 'Description', 'Status', 'Notes'],
          ['Sample Item 1', 'First item description', 'Active', 'Initial entry'],
          ['Sample Item 2', 'Second item description', 'Pending', 'Follow-up needed']
        ];
        const result = await createSpreadsheet(this.tokens, title, data);
        return {
          created: true,
          documentType: 'spreadsheet',
          title: title,
          link: result.spreadsheetUrl,
          url: result.spreadsheetUrl
        };
      } else if (isPresentation) {
        // Parse content into slides - look for "Slide X:" patterns or split by double newlines
        let slides = [];
        
        // Try to parse structured slide format (e.g., "Slide 1: Title\nContent")
        const slidePattern = /Slide\s+\d+:\s*([^\n]+)(?:\n\n?([^\n]+(?:\n[^\n]+)*))?/gi;
        const matches = [...content.matchAll(slidePattern)];
        
        if (matches.length > 0) {
          slides = matches.map((match, idx) => ({
            title: match[1].trim() || `Slide ${idx + 1}`,
            content: (match[2] || '').trim()
          }));
        } else {
          // Fallback: split by double newlines and extract titles from first line
          const sections = content.split(/\n\n+/).filter(s => s.trim());
          slides = sections.map((section, idx) => {
            const lines = section.trim().split('\n');
            const firstLine = lines[0];
            // If first line looks like a title (short, no period, or ends with colon)
            if (firstLine.length < 60 && (!firstLine.includes('.') || firstLine.endsWith(':'))) {
              return {
                title: firstLine.replace(/[:.]$/, '').trim() || `Slide ${idx + 1}`,
                content: lines.slice(1).join('\n').trim() || firstLine
              };
            } else {
              return {
                title: `Slide ${idx + 1}`,
                content: section.trim()
              };
            }
          });
        }
        
        // Ensure we have at least one slide
        if (slides.length === 0) {
          slides = [{
            title: title,
            content: content || 'Welcome to this presentation.'
          }];
        }
        
        const result = await createPresentation(this.tokens, title, slides);
        return {
          created: true,
          documentType: 'presentation',
          title: title,
          link: result.presentationUrl,
          url: result.presentationUrl
        };
      } else {
        const result = await createDocument(this.tokens, title, content);
        return {
          created: true,
          documentType: 'document',
          title: title,
          link: result.documentUrl,
          url: result.documentUrl
        };
      }
    } catch (error) {
      return {
        error: true,
        message: `Error creating document: ${error.message}`
      };
    }
  }

  // Helper functions (unchanged)
  async getTravelInfoForMeeting(event) {
    if (!event.location || event.location === 'No location specified') {
      return null;
    }
    return `ðŸ“ Meeting location: ${event.location}\n\nTo calculate travel time, please provide your current location.`;
  }
  getTimeUntil(date) {
    const now = new Date(); const diff = date - now;
    if (diff < 0) return 'Past event';
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    if (hours > 0) { return `In ${hours} hour(s) and ${minutes} minute(s)`; }
    return `In ${minutes} minute(s)`;
  }
  getTimeUntilInHours(date) {
    const now = new Date(); const diff = date - now;
    return diff / (1000 * 60 * 60);
  }
  formatTimeUntil(date) {
    const now = new Date(); const diff = date - now;
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    if (hours > 0) { return `${hours}h ${minutes}m`; }
    return `${minutes}m`;
  }
  formatDateTime(date) {
    return date.toLocaleString('en-US', {
      weekday: 'short', month: 'short', day: 'numeric',
      hour: 'numeric', minute: '2-digit'
    });
  }

  // --- All other handlers updated with new signature ---

  async handleTasksQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('create') || lowerQuery.includes('add') || lowerQuery.includes('new')) {
        const titleMatch = query.match(/(?:create|add|new) (?:a )?task (?:called |named )?(.+)/i);
        const title = titleMatch ? titleMatch[1].trim() : 'New Task';
        
        const task = await createTask(this.tokens, '@default', title);
        return {
          created: true,
          task: task,
          title: title
        };
      }
      
      const tasks = await getUpcomingTasks(this.tokens, 10);
      
        return {
        tasksFound: tasks.length > 0,
        tasks: tasks,
        taskCount: tasks.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error fetching tasks: ${error.message}`
      };
    }
  }

  async handleContactsQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('search') || lowerQuery.includes('find')) {
        const searchTerm = query.replace(/(?:search|find) (?:for )?(?:contact|person|people) (?:named |called )?/i, '').trim();
        if (searchTerm) {
          const contacts = await searchContacts(this.tokens, searchTerm);
            return {
            searchPerformed: true,
            searchTerm: searchTerm,
            contactsFound: contacts.length > 0,
            contacts: contacts,
            contactCount: contacts.length
          };
        }
      }
      
      const contacts = await getContacts(this.tokens, 20);
      
        return {
        searchPerformed: false,
        contactsFound: contacts.length > 0,
        contacts: contacts.slice(0, 10),
        contactCount: contacts.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error fetching contacts: ${error.message}`
      };
    }
  }

  async handleMeetQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('create') || lowerQuery.includes('schedule') || lowerQuery.includes('new')) {
        const titleMatch = query.match(/(?:create|schedule|new) (?:a )?meet(?:ing)? (?:called |named )?(.+?)(?: at|$)/i);
        const title = titleMatch ? titleMatch[1].trim() : 'New Meeting';
        
        const startTime = new Date();
        startTime.setHours(startTime.getHours() + 1);
        const endTime = new Date(startTime);
        endTime.setHours(endTime.getHours() + 1);
        
        const meetEvent = await createMeetEvent(
          this.tokens,
          title,
          startTime.toISOString(),
          endTime.toISOString()
        );
        
        return {
          created: true,
          title: title,
          link: meetEvent.meetLink,
          meetLink: meetEvent.meetLink,
          start: meetEvent.start,
          end: meetEvent.end
        };
      }
      
      const nextMeet = await getNextMeetLink(this.tokens);
      
        return {
        created: false,
        meetingFound: nextMeet ? true : false,
        meeting: nextMeet,
        link: nextMeet ? nextMeet.meetLink : null
      };
    } catch (error) {
      return {
        error: true,
        message: `Error with Google Meet: ${error.message}`
      };
    }
  }

  async handleDriveQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('search') || lowerQuery.includes('find')) {
        const searchTerm = query.replace(/(?:search|find) (?:for )?(?:file|document) (?:named |called )?/i, '').trim();
        if (searchTerm) {
          const files = await searchFiles(this.tokens, searchTerm);
            return {
            searchPerformed: true,
            searchTerm: searchTerm,
            filesFound: files.length > 0,
            files: files.slice(0, 10),
            fileCount: files.length
          };
        }
      }
      
      const files = await getRecentFiles(this.tokens, 10);
      
        return {
        searchPerformed: false,
        filesFound: files.length > 0,
        files: files,
        fileCount: files.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error accessing Drive: ${error.message}`
      };
    }
  }

  async handleNotesQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('create') || lowerQuery.includes('add') || lowerQuery.includes('new')) {
        const titleMatch = query.match(/(?:create|add|new) (?:a )?note (?:called |named )?(.+?)(?: with|$)/i);
        const contentMatch = query.match(/with (.+?)(?:$|called|named)/i);
        
        const title = titleMatch ? titleMatch[1].trim() : 'New Note';
        const content = contentMatch ? contentMatch[1].trim() : '';
        
        const note = await createNote(this.tokens, title, content);
        
        return {
          created: true,
          title: title,
          link: note.noteUrl,
          noteUrl: note.noteUrl
        };
      }
      
      if (lowerQuery.includes('search') || lowerQuery.includes('find')) {
        const searchTerm = query.replace(/(?:search|find) (?:for )?note(?:s)? (?:about |named )?/i, '').trim();
        if (searchTerm) {
          const notes = await searchNotes(this.tokens, searchTerm);
          return {
            searchPerformed: true,
            searchTerm: searchTerm,
            notesFound: notes.length > 0,
            notes: notes.slice(0, 10),
            noteCount: notes.length
          };
        }
      }
      
      const notes = await getNotes(this.tokens, 10);
      
            return {
        searchPerformed: false,
        notesFound: notes.length > 0,
        notes: notes,
        noteCount: notes.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error with notes: ${error.message}`
      };
    }
  }

  async handleGmailQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('search') || lowerQuery.includes('find')) {
        const searchTerm = query.replace(/(?:search|find) (?:for )?(?:email|mail|message)(?:s)? (?:from |about )?/i, '').trim();
        if (searchTerm) {
          const messages = await searchMessages(this.tokens, searchTerm, 10);
          return {
            searchPerformed: true,
            searchTerm: searchTerm,
            messagesFound: messages.length > 0,
            messages: messages,
            messageCount: messages.length
          };
        }
      }
      
      const messages = await getMessages(this.tokens, 10);
      
        return {
        searchPerformed: false,
        messagesFound: messages.length > 0,
        messages: messages,
        messageCount: messages.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error fetching emails: ${error.message}`
      };
    }
  }

  async handleSearchQuery(query, currentLocation = null) {
    try {
      const searchResults = await googleSearch(this.tokens, query, 10);
      return {
        searchPerformed: true,
        query: query,
        resultsFound: searchResults.results.length > 0,
        results: searchResults.results,
        totalResults: searchResults.totalResults
      };
    } catch (error) {
      return {
        error: true,
        message: `Error performing search: ${error.message}`
      };
    }
  }

  async handleFormsQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('create') || lowerQuery.includes('make') || lowerQuery.includes('new')) {
        // Extract title
        const titleMatch = query.match(/(?:create|make|new) (?:a )?form(?: called |named |titled )?(.+?)(?: with| including| containing|$)/i);
        const title = titleMatch ? titleMatch[1].trim() : 'New Form';
        
        // Try to extract questions from the query
        // Look for patterns like "with questions:", "including:", or question lists
        let questions = [];
        const questionsMatch = query.match(/(?:with|including|containing|questions?)(?::|,)?\s*(.+)/i);
        if (questionsMatch) {
          const questionsText = questionsMatch[1];
          // Try to parse questions - could be a list or structured format
          // For now, let Gemini handle the parsing via tool calls
          // We'll create the form first and then add questions if provided
        }
        
        const form = await createForm(this.tokens, title, '', questions);
        return {
          created: true,
          form: form,
          title: title,
          link: form.formUrl,
          questionsAdded: questions.length
        };
      }
      
      if (lowerQuery.includes('add question') || lowerQuery.includes('add a question')) {
        const formIdMatch = query.match(/form[:\s]+([a-zA-Z0-9_-]+)/i);
        if (!formIdMatch) {
          return {
            error: true,
            message: "Please specify the form ID to add a question to"
          };
        }
        const formId = formIdMatch[1];
        
        // Extract question details from query
        // This is a simplified parser - Gemini should provide structured data
        const questionText = query.replace(/.*(?:add|add a) question(?: to form[:\s]+[a-zA-Z0-9_-]+)?[:\s]+/i, '').trim();
        
        if (!questionText) {
          return {
            error: true,
            message: "Please provide the question text"
          };
        }
        
        // Try to detect question type
        let questionType = 'text';
        let options = [];
        
        if (lowerQuery.includes('multiple choice') || lowerQuery.includes('radio')) {
          questionType = 'multiple_choice';
          // Try to extract options
          const optionsMatch = query.match(/options?[:\s]+(.+)/i);
          if (optionsMatch) {
            options = optionsMatch[1].split(',').map(opt => opt.trim());
          }
        } else if (lowerQuery.includes('checkbox') || lowerQuery.includes('checkboxes')) {
          questionType = 'checkbox';
          const optionsMatch = query.match(/options?[:\s]+(.+)/i);
          if (optionsMatch) {
            options = optionsMatch[1].split(',').map(opt => opt.trim());
          }
        } else if (lowerQuery.includes('dropdown') || lowerQuery.includes('select')) {
          questionType = 'dropdown';
          const optionsMatch = query.match(/options?[:\s]+(.+)/i);
          if (optionsMatch) {
            options = optionsMatch[1].split(',').map(opt => opt.trim());
          }
        } else if (lowerQuery.includes('paragraph') || lowerQuery.includes('long text')) {
          questionType = 'paragraph';
        }
        
        const question = {
          title: questionText,
          type: questionType,
          options: options,
          required: lowerQuery.includes('required')
        };
        
        await addQuestionToForm(this.tokens, formId, question);
        return {
          questionAdded: true,
          formId: formId,
          question: question
        };
      }
      
      if (lowerQuery.includes('edit question') || lowerQuery.includes('update question')) {
        const formIdMatch = query.match(/form[:\s]+([a-zA-Z0-9_-]+)/i);
        const questionIdMatch = query.match(/question[:\s]+([a-zA-Z0-9_-]+)/i);
        
        if (!formIdMatch || !questionIdMatch) {
          return {
            error: true,
            message: "Please specify both form ID and question ID"
          };
        }
        
        const formId = formIdMatch[1];
        const questionId = questionIdMatch[1];
        
        // Extract updates
        const updates = {};
        if (lowerQuery.includes('title') || lowerQuery.includes('text')) {
          const titleMatch = query.match(/(?:title|text)[:\s]+(.+?)(?:$|,)/i);
          if (titleMatch) {
            updates.title = titleMatch[1].trim();
          }
        }
        if (lowerQuery.includes('required')) {
          updates.required = true;
        }
        if (lowerQuery.includes('not required') || lowerQuery.includes('optional')) {
          updates.required = false;
        }
        
        await updateQuestion(this.tokens, formId, questionId, updates);
        return {
          questionUpdated: true,
          formId: formId,
          questionId: questionId
        };
      }
      
      if (lowerQuery.includes('delete question') || lowerQuery.includes('remove question')) {
        const formIdMatch = query.match(/form[:\s]+([a-zA-Z0-9_-]+)/i);
        const questionIdMatch = query.match(/question[:\s]+([a-zA-Z0-9_-]+)/i);
        
        if (!formIdMatch || !questionIdMatch) {
          return {
            error: true,
            message: "Please specify both form ID and question ID"
          };
        }
        
        const formId = formIdMatch[1];
        const questionId = questionIdMatch[1];
        
        await deleteQuestion(this.tokens, formId, questionId);
        return {
          questionDeleted: true,
          formId: formId,
          questionId: questionId
        };
      }
      
      if (lowerQuery.includes('get') || lowerQuery.includes('view') || lowerQuery.includes('show')) {
        const formIdMatch = query.match(/form[:\s]+([a-zA-Z0-9_-]+)/i);
        if (formIdMatch) {
          const formId = formIdMatch[1];
          const form = await getForm(this.tokens, formId);
          return {
            formFound: true,
            form: form,
            formId: formId
          };
        }
      }
      
      if (lowerQuery.includes('list') || lowerQuery.includes('show') || lowerQuery.includes('get all')) {
        const forms = await listForms(this.tokens, 20);
        return {
          formsFound: forms.length > 0,
          forms: forms,
          formCount: forms.length
        };
      }
      
      if (lowerQuery.includes('delete') || lowerQuery.includes('remove')) {
        const formIdMatch = query.match(/form[:\s]+([a-zA-Z0-9_-]+)/i);
        if (formIdMatch) {
          const formId = formIdMatch[1];
          await deleteForm(this.tokens, formId);
          return {
            deleted: true,
            formId: formId
          };
        }
        return {
          error: true,
          message: "Please specify the form ID to delete"
        };
      }
      
      if (lowerQuery.includes('responses') || lowerQuery.includes('answers')) {
        const formIdMatch = query.match(/form[:\s]+([a-zA-Z0-9_-]+)/i);
        if (formIdMatch) {
          const formId = formIdMatch[1];
          const responses = await getFormResponses(this.tokens, formId);
          return {
            responsesFound: responses.length > 0,
            responses: responses,
            responseCount: responses.length
          };
        }
        return {
          error: true,
          message: "Please specify the form ID to get responses"
        };
      }
      
      // Default: list forms
      const forms = await listForms(this.tokens, 10);
      return {
        formsFound: forms.length > 0,
        forms: forms,
        formCount: forms.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error with forms: ${error.message}`
      };
    }
  }

  async handleYouTubeQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('search') || lowerQuery.includes('find') || lowerQuery.includes('videos')) {
        const searchTerm = query.replace(/(?:search|find) (?:for )?(?:video|youtube)(?:s)? (?:about |named )?/i, '').trim();
        const cleanQuery = searchTerm || query.replace(/youtube/i, '').trim();
        
        const results = await searchVideos(this.tokens, cleanQuery, 10);
            return {
          searchPerformed: true,
          query: cleanQuery,
          videosFound: results.videos.length > 0,
          videos: results.videos,
          videoCount: results.videos.length,
          totalResults: results.totalResults
        };
      }
      
      if (lowerQuery.includes('video') && (lowerQuery.includes('details') || lowerQuery.includes('info'))) {
        const videoIdMatch = query.match(/video[:\s]+([a-zA-Z0-9_-]{11})/i);
        if (videoIdMatch) {
          const videoId = videoIdMatch[1];
          const video = await getVideoDetails(this.tokens, videoId);
          return {
            videoFound: !!video,
            video: video
          };
        }
        return {
          error: true,
          message: "Please provide a video ID"
        };
      }
      
      if (lowerQuery.includes('channel') || lowerQuery.includes('channel info')) {
        const channelIdMatch = query.match(/channel[:\s]+([a-zA-Z0-9_-]+)/i);
        if (channelIdMatch) {
          const channelId = channelIdMatch[1];
          const channel = await getChannelInfo(this.tokens, channelId);
          return {
            channelFound: !!channel,
            channel: channel
          };
        }
        return {
          error: true,
          message: "Please provide a channel ID"
        };
      }
      
      if (lowerQuery.includes('playlist') || lowerQuery.includes('playlists')) {
        const playlists = await getMyPlaylists(this.tokens, 20);
        return {
          playlistsFound: playlists.length > 0,
          playlists: playlists,
          playlistCount: playlists.length
        };
      }
      
      // Default: search videos
      const results = await searchVideos(this.tokens, query, 10);
        return {
        searchPerformed: true,
        query: query,
        videosFound: results.videos.length > 0,
        videos: results.videos,
        videoCount: results.videos.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error with YouTube: ${error.message}`
      };
    }
  }

  async handleWeatherQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      // Extract location from query
      let location = null;
      
      // Check if user is asking for current location
      if (lowerQuery.includes('my location') || lowerQuery.includes('current location') || lowerQuery.includes('here')) {
        location = currentLocation;
      } else {
        // Try to extract location name from query
        const locationPatterns = [
          /(?:weather|temperature|forecast) (?:in|at|for) (.+?)(?:$|,|\.)/i,
          /(.+?) (?:weather|temperature|forecast)/i
        ];
        
        for (const pattern of locationPatterns) {
          const match = query.match(pattern);
          if (match && match[1]) {
            const extractedLocation = match[1].trim();
            // Don't use "my location" as extracted location
            if (!extractedLocation.toLowerCase().includes('my location') && 
                !extractedLocation.toLowerCase().includes('current location') &&
                !extractedLocation.toLowerCase().includes('here')) {
              location = extractedLocation;
              break;
            }
          }
        }
      }
      
      // If no location extracted and we have currentLocation, use it
      if (!location && currentLocation) {
        location = currentLocation;
      } else if (!location) {
        location = 'current location'; // Will be handled by geocoding
      }
      
      if (lowerQuery.includes('forecast') || lowerQuery.includes('forecast')) {
        const days = 5;
        const forecast = await getWeatherForecast(this.tokens, location, days);
      return {
          forecast: true,
          location: forecast.location,
          forecasts: forecast.forecasts,
          forecastCount: forecast.forecasts.length
        };
      }
      
      const weather = await getWeather(this.tokens, location);
      return {
        weatherFound: true,
        weather: weather,
        location: weather.location
      };
    } catch (error) {
      return {
        error: true,
        message: `Error getting weather: ${error.message}`
      };
    }
  }

  async handlePlacesQuery(query, currentLocation = null) {
    const lowerQuery = query.toLowerCase();
    
    try {
      if (lowerQuery.includes('nearby') || lowerQuery.includes('near me')) {
        if (!currentLocation) {
          return {
            error: true,
            message: "Current location is required for nearby places search"
          };
        }
        
        // Extract place type if mentioned
        let type = null;
        const typeKeywords = {
          'restaurant': 'restaurant',
          'cafe': 'cafe',
          'coffee': 'cafe',
          'hotel': 'lodging',
          'gas': 'gas_station',
          'hospital': 'hospital',
          'pharmacy': 'pharmacy',
          'bank': 'bank',
          'atm': 'atm',
          'parking': 'parking',
          'store': 'store',
          'shopping': 'shopping_mall'
        };
        
        for (const [keyword, placeType] of Object.entries(typeKeywords)) {
          if (lowerQuery.includes(keyword)) {
            type = placeType;
            break;
          }
        }
        
        const places = await getNearbyPlaces(this.tokens, currentLocation, type, 5000);
        return {
          nearbySearch: true,
          location: currentLocation,
          placesFound: places.places.length > 0,
          places: places.places,
          placeCount: places.places.length
        };
      }
      
      if (lowerQuery.includes('details') || lowerQuery.includes('info')) {
        const placeIdMatch = query.match(/place[:\s]+([a-zA-Z0-9_-]+)/i);
        if (placeIdMatch) {
          const placeId = placeIdMatch[1];
          const place = await getPlaceDetails(this.tokens, placeId);
          return {
            placeFound: !!place,
            place: place
          };
        }
        return {
          error: true,
          message: "Please provide a place ID"
        };
      }
      
      // Default: search places
      const searchTerm = query.replace(/(?:search|find) (?:for )?place(?:s)? (?:named |called )?/i, '').trim();
      const results = await searchPlaces(this.tokens, searchTerm || query, currentLocation);
      return {
        searchPerformed: true,
        query: searchTerm || query,
        placesFound: results.places.length > 0,
        places: results.places,
        placeCount: results.places.length
      };
    } catch (error) {
      return {
        error: true,
        message: `Error with places: ${error.message}`
      };
    }
  }

  async handleTimezoneQuery(query, currentLocation = null) {
    try {
      // Extract location from query
      let location = currentLocation;
      
      const locationPatterns = [
        /(?:timezone|time) (?:in|at|for) (.+?)(?:$|,|\.)/i,
        /(.+?) (?:timezone|time)/i
      ];
      
      for (const pattern of locationPatterns) {
        const match = query.match(pattern);
        if (match && match[1]) {
          location = match[1].trim();
          break;
        }
      }
      
      if (!location) {
        location = currentLocation || 'current location';
      }
      
      const timezone = await getTimezone(this.tokens, location);
      return {
        timezoneFound: true,
        timezone: timezone,
        location: location
      };
    } catch (error) {
      return {
        error: true,
        message: `Error getting timezone: ${error.message}`
      };
    }
  }

  async handleAirQualityQuery(query, currentLocation = null) {
    try {
      const lowerQuery = query.toLowerCase();
      
      // Extract location from query
      let location = currentLocation;
      
      const locationPatterns = [
        /(?:air quality|aqi|pollution) (?:in|at|for) (.+?)(?:$|,|\.)/i,
        /(.+?) (?:air quality|aqi|pollution)/i
      ];
      
      for (const pattern of locationPatterns) {
        const match = query.match(pattern);
        if (match && match[1]) {
          location = match[1].trim();
          break;
        }
      }
      
      if (!location) {
        location = currentLocation || 'current location';
      }
      
      if (lowerQuery.includes('forecast') || lowerQuery.includes('forecast')) {
        const hours = 24;
        const forecast = await getAirQualityForecast(this.tokens, location, hours);
        return {
          forecast: true,
          location: forecast.location,
          forecasts: forecast.forecasts,
          forecastCount: forecast.forecasts.length
        };
      }
      
      const airQuality = await getAirQuality(this.tokens, location);
      return {
        airQualityFound: true,
        airQuality: airQuality,
        location: airQuality.location
      };
    } catch (error) {
      return {
        error: true,
        message: `Error getting air quality: ${error.message}`
      };
    }
  }
}